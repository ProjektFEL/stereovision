
#include "IProcess.h"
#include <omp.h>
#include <opencv2/core.hpp>
#include <opencv2/calib3d.hpp>
#include "opencv2/opencv.hpp"

class ProcessA : public IProcess {
private:
	thread *t;
	cv::Mat copyLeft, copyRight, copyDisparity;
	cv::Mat gradient, removedGradient;
	int kernelSize;
	cv::Mat fgMaskMOG; //fg mask generated by MOG method
	cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	cv::Ptr<cv::BackgroundSubtractor> pMOG; //MOG Background subtractor
	cv::Ptr<cv::BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
public:	 
	ProcessA(){
		kernelSize = 2;
		pMOG = cv::createBackgroundSubtractorKNN(); //MOG approach
		pMOG2 = cv::createBackgroundSubtractorMOG2();
	}

	~ProcessA()
	{}


	thread* run(mutex* z, cv::Mat frameLeft, cv::Mat frameRight)
	{
		z->lock();
		frameLeft.copyTo(copyLeft);
		frameRight.copyTo(copyRight);
		z->unlock();
		t = new thread(&ProcessA::process, this, copyLeft, copyRight);
		return t;
	}

	void work(cv::Mat frameLeft, cv::Mat frameRight){
		for (int i = 1; i <= 100; i++)
		{
			cout << "ProcessA: " << i << endl;
		}
	}


	void process(cv::Mat disparity, cv::Mat frameRight){


		//int ddepth = -1;                                                           // hlbka vystupu z filtra bude rovnaka ako vstupu
		//Mat kernel = Mat(kernelSize, kernelSize, CV_32F);    // kernel je stvorec, typ je double
		//for (int i = 0; i < kernelSize; i++) {

		//	for (int j = 0; j < kernelSize; j++)
		//	{
		//		kernel.at<float>(i, j) = ((float)(kernelSize / 2) - (float)i) * 2;
		//		//	kernel.at<float>(i, j) = (float)kernelSize ;
		//	}
		//}
		//filter2D(disparityFrame, removedGradient, ddepth, kernel);
		//bitwise_not(removedGradient, removedGradient);
		////inRange(noGradient,lowTSH,highTSH,noGradient);
		////invert(noGradient,noGradient,DECOMP_NORMAL);

		pMOG->apply(disparity, removedGradient);
		//pMOG2->apply(disparity, removedGradient);


		
	 }

	cv::Mat getFrame(){
		 return removedGradient;
	 }

	 // este prerobit tuto funkciu, zla navratova hodnota
	cv::Mat getObject() {
			 return removedGradient;
	 }

};