
#include "IProcess.h"
#include <omp.h>
#include <opencv2/core.hpp>
#include <opencv2/calib3d.hpp>
#include "opencv2/opencv.hpp"

class ProcessA : public IProcess {
private:
	Mat removedGradient;
	int kernelSize;
	Mat fgMaskMOG; //fg mask generated by MOG method
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
	Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
public:	 
	ProcessA(){
		kernelSize = 2;
		pMOG = createBackgroundSubtractorKNN(); //MOG approach
		pMOG2 = createBackgroundSubtractorMOG2();
	}

	void process(Mat disparityFrame, Mat frameRight){

		//int ddepth = -1;                                                           // hlbka vystupu z filtra bude rovnaka ako vstupu
		//Mat kernel = Mat(kernelSize, kernelSize, CV_32F);    // kernel je stvorec, typ je double
		//for (int i = 0; i < kernelSize; i++) {

		//	for (int j = 0; j < kernelSize; j++)
		//	{
		//		kernel.at<float>(i, j) = ((float)(kernelSize / 2) - (float)i) * 2;
		//		//	kernel.at<float>(i, j) = (float)kernelSize ;
		//	}
		//}
		//filter2D(disparityFrame, removedGradient, ddepth, kernel);
		//bitwise_not(removedGradient, removedGradient);
		////inRange(noGradient,lowTSH,highTSH,noGradient);
		////invert(noGradient,noGradient,DECOMP_NORMAL);

		pMOG->apply(disparityFrame, removedGradient);
		pMOG2->apply(disparityFrame, removedGradient);


		
	 }

	 Mat getFrame(){
		 return removedGradient;
	 }

	 // este prerobit tuto funkciu, zla navratova hodnota
		 Mat getObject() {
			 return removedGradient;
	 }

		 ~ProcessA()
		 {}


};